<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Rust for php devs</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		<script src="jquery-3.0.0.min.js"></script>
	</head>


	<script type="application/javascript">
		$(document).ready(function() {
			$('.editor').each(function (i, v) {

				$(v).css({
					'height': $(document).height() -400,
					'border': '3px silver',
					'display': 'flex',
					'justify-content': 'flex-start'
				});

				//var rust_pen = "http://127.0.0.1:8080/";
				var rust_pen = "https://play.rust-lang.org/";

				var rust_code = encodeURIComponent($(v).html().trim().replace(/\&gt\;/g, '>').replace(/\&lt\;/g, '<').replace(/\&amp\;/g, '&'));

				if (!$(v).parent().find('.php_example').html()) {
					$(v).html('');
					$(v).append($('<iframe style="flex: 1 1 auto"/>').attr('src', rust_pen + '/?code=' + rust_code));
					return;
				}

				var php_code = $(v).parent().find('.php_example').html().trim();//.replace(/\&gt\;/g, '>').replace(/\&lt\;/g, '<').replace(/\&amp\;/g, '&');
				var php_example_url = $(v).parent().find('.php_example').data('php-example');


				$(v).html('');
				$(v).parent().find('.php_example').remove();

				$(v).append($('<iframe style="flex: 1 1 auto;overflow:scroll"/>').attr('src', rust_pen + '/?code=' + rust_code));

				var php_code_node = $('<div><pre><code data-trim data-noescape class="php">' + php_code + '</code></pre><center><small><i>(clickable)</i></small></center></div>');

				$(v).append($('<div style="flex: 1 1 auto;overflow:scroll"/>').html(php_code_node));

				if (php_example_url) {
					php_code_node.on('click', function() {
						php_code_node.parent().remove(); //.html($('<iframe style="flex: 1 1 auto"/>').attr('src', php_example_url));
						$(v).append($('<iframe style="flex: 1 1 auto;overflow:scroll"/>').attr('src', php_example_url));
					});

				}
			});

			$('.editor > *').each(function(i, v) {
				//$(v).css('margin', '10px');
			}).mouseenter(function(e) {
				$(e.target).css('flex', '95 1 auto');
				$(e.target).siblings().css('width', 100);
				$(e.target).siblings().css('flex', '1 1 auto');
			})
			.mouseleave(function(e) {
				$(e.target).css('flex', '1 1 auto');
				$(e.target).css('width', '');
				$(e.target).siblings().css('width', '');
			});
		});


	</script>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<!--
				<section>
					Iterator example analog zur SPL: https://doc.rust-lang.org/src/core/up/src/libcore/iter.rs.html#109
				</section>

				<section>
					Zero Cost Abstractions
				</section>

				<section>
					Testing + Docs
				</section>

				<section>
					Error Messages
				</section>

				<section>
					No Implicit type conversion
				</section>

				<section>
					Safe Abstractions
				</section>

				<section>
					Zero cost abstractions
					move semantics
					quaranteed memory
					threads without pain
					oop
					lovely syntax
				</section>


				<section>
					Why Rust slide http://pnkfelix.github.io/curry-on2015.html#/
					Servo
				</section>


				<section>
					what is rust good at:
					http://people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/11/2
				</section>

				<section>
					Self Containted (one huge exe)
				</section>

				-->



				<!--
				<section style="text-align: left;">

					<pre><code data-trim data-noescape>
					(def lazy-fib
					  (concat
					   [0 1]
					   <mark>((fn rfib [a b]</mark>
							(lazy-cons (+ a b) (rfib b (+ a b)))) 0 1)))
						</code></pre>

				</section>
				-->

				<section>
					<div class="editor">
can't read?
better come closer =)
					</div>

					<div class="php_example" data-php-example="https://3v4l.org/sGAuT">
						echo "{K]X^\31\31EYG_Q\31"^"".M_PI;
					</div>

				</section>


				<section style="text-align: left;">

					<h1>Rust for PHP devs</h1>

					<aside class="notes">
						<ul>
							<li>Ja, Hallo und herzlich willkommen.</li>
							<li>Wir werden uns heute mit dem Thema Rust für PHP Dev's beschäftigen</li>
							<li>Wer von euch hat sich denn hier eingeschlichen und ist garkein PHP Dev?</li>
							<li>Wer von euch hat denn schon mal von Rust gehört?</li>
							<li>Ich hatte den Talk ja irgendwann vorletzte Woche angekündigt und darauf folgte prompt diese Reaktion</li>
						</ul>
					</aside>

				</section>

				<section>
					<img src="oh_no.png"/>
					<aside class="notes">
						<ul>
							<li>War natürlich Spass, aber irgendwo steckt immer ein stück "Warheit"</li>
							<li>
								hat jemand von euch schon mal
								<ul>
									<li>von diesem "system code" gehört?</li>
									<li>und warum sollte man uns nicht erlauben diesen zu schreiben?</li>
									<li>
										Wir werden und in diesem Talk damit beschäftigen
										<ul>
											<li>Warum Rust die Chance für euch ist "system code" zu schreiben.</li>
											<li>ohne die schmerzen von C/C++</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="ich.jpeg" style="max-width:200px"><br/>
					<i>@timglabisch</i>
					<br/>
					<img src="github_stats.png" style="max-width:370px"/>
					<aside class="notes">
						<ul>
							<li>Ich bin Tim</li>
							<li>Wer mich schon mal im Internet gesehen hat, vermutlich mit diesem Bild</li>
							<li>
								Ich Maintaine Deptrac primär
								<ul>
									<li>Wenn Deptrac doof ist, und rust doof ist, dann hab ich euch wohl den abend versaut x)</li>
								</ul>
							</li>
							<li>
								... Und Github denkt ich würde in diesen Sprachen entwickeln
								<ul>
									<li>Das ist definitiv falsch, ich mach kein Basic x)</li>
									<li>gibt aber vielleicht ein ganz guten Überblick über meinen "sprachlichen" Background</li>
								</ul>
							</li>
							<li>
								Ich arbeite hier für Sensiolabs
								<ul>
									<li>
										Und wie jede andere Firma, suchen wir natürlich auch nach neuen tollen mitarbeitern,
										wer also interesse hat, gerne einfach mich, andreas und freerich ansprechen.
									</li>
								</ul>
							</li>

							<li>
								Der Titel des Talks war ja Rust für PHP Devs
								<ul>
									<li>In diesem Sinne hab ich heute viel Code mitgebracht</li>
									<li>Ich hab aber auch viele Slides mitgebracht</li>
									<li>Sollte ich euch deutlich zu schnell werden, einfach aufschreien oder mit irgendwas nach mir werfen.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>


				<section style="text-align: left;">

					<div class="editor">
pub fn main() {
	println!("Hello PHPUG!");
}
					</div>

					<div class="php_example" data-php-example="https://3v4l.org/sGAuT">
echo sprintf("%s", "Hello PHPUG!");
					</div>

					<aside class="notes">
						<ul>
							<li>Wie versprochen der erste Code.</li>
							<li>Ich hab in den Slides oft diesen Editor eingebunden</li>
							<li>Oft mit php Beispiel auf der rechten Seite</li>
							<li>Links in dem weißen Fenster ist immer der Rust Code</li>
							<li>Rechts der PHP Code</li>
							<li>den Rust Code links kann man verändern und auf Run klicken</li>
							<li>den php code, immer wenn da (clickable) steht drauf klicken und online ausführen</li>
							<li>je nachdem wo die maus grade ist, verändert sich die fenstergröße</li>
							<li>
								wir können mit dem ein oder anderen Beispiel ein wenig rumspielen, hab aber wiegesagt einige slides mitgebracht und zeitfenster ...
							</li>
							<li>
								hier haben wir als erstes einmal ein kleines Hallo Welt Beispiel
							</li>
							<li>
								Fragen bier hier her?
							</li>
						</ul>
					</aside>
				</section>

				<section>

					<div class="editor">
pub fn main() {
	let foo = "bar";

	println!("Hello {}", foo);
}
					</div>

					<aside class="notes">
						<ul>
							<li>Variablen werden immer mit einem "let" wie in JS deklariert.</li>
							<li>Rust findet den Typen dann selbst raus und nutzt den (Rust ist stark typisiert)</li>
							<li>Typen brauch man in Rust nur selten zu schreiben, idr nur in Funktionssignaturen</li>
						</ul>
					</aside>

				</section>

				<section>

					<div class="editor">
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "PHPUG".to_string();

	greet(name);
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/B6C93">

function greet(string $name) {
    echo sprintf(
		"Hello %s",
		$name
	);
}

$name = "PHPUG";
greet($name);
					</div>

					<aside class="notes">
						<ul>
							<li>Hier sehen wir eine Funktion welche aufgerufen wird (greet)</li>
							<li>Typisierung der Funktion (String) ist steht auf der rechten seite (ungewohnt)</li>
							<li>sieht php recht ähnlich ...</li>
							<li>ich werde für den Moment noch nicht auf das .to_string() eingehen, vielleicht schaffen wir das gleich noch</li>
						</ul>
					</aside>


				</section>

				<section>

					<div class="editor">
struct Person {
	pub age: i32
}

pub fn main() {
	let tim = Person { age: 25 };

	println!("tim is {} years old", tim.age);
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/s9cMe">
class Person {
    public $age = null;
}

$tim = new Person();
$tim->age = 25;
echo sprintf(
	"Tim is %d years old",
	$tim->age
);

					</div>

					<aside class="notes">
						<ul>
							<li>Rust kennt keine Klassen (OOP) ist aber möglich.</li>
							<li>Rust nutzt hier einfach sogenannte "structs" wo methoden dran gehangen werden können.</li>
							<li>Das hat z.b. den Vorteil, dass diese Structs kompatibel mit Structs in C sein können.</li>
							<li>In PHP würde man dies wohl mit einer einer Klasse realisiert werden</li>
							<li>auch wenn der code ähnlich ausschaut, was unter der haube passiert ist was völlig anderes</li>
						</ul>
					</aside>

				</section>


				<section>

					<div class="editor">
struct Person {
	age: i32
}

impl Person {
	pub fn new(age : i32) -> Person {
		Person {
			age: age
		}
	}
}

pub fn main() {
	let tim = Person::new(25);

	println!("tim is {} years old", tim.age);
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/X8SVu">

class Person {
    public $age;

    private function __construct(int $age) {
        $this->age = $age;
    }

    public static function newWithAge(int $age) : Person {
        return new static($age);
    }
}

$tim = Person::newWithAge(25);
echo sprintf("Tim is %d years old", $tim->age);

					</div>

					<aside class="notes">
						<ul>
							<li>Hier haben wir auf der rechten seite eine Typische Klasse in PHP (mit einem named Constructor)</li>
							<li>Der Konstruktor (statische Funktion) erlaubt das erstellen einer Person mit einem Alter</li>
							<li>Der Rückgabewert des Construktors ist eine Person (php7)</li>
							<li>im anschluss lässt sich eine Person erstellen, mit einem alter, und das alter ausgeben</li>
							<li>...recht klassisches php...</li>
							<li>
								Schauen wir uns den Rust Code an
								<ul>
									<li>wir definieren ein struct (unserer properties in php)</li>
									<li>Rust kennt nur "named constructors (new ist lediglich eine Namenskonvention)</li>
									<li>In Rust wird immer die letzte Expression zurückgegeben, man spart sich also das "return"</li>
									<li>Im Anschluss kein über ::new Instanz erstellt werden</li>
									<li>Diese kann dann wie gewohnt verwendet werden</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Warum Rust?</h3>

					<aside class="notes">
						<ul>
							<li>warum noch eine Sprache?</li>
							<li>Heute stell ich rust vor, gestern CoffeeScript, und morgen?</li>
							<li>
								Die Beispiele die wir eben gesehen haben, hauen einen ja nicht sonderlich um
								<ul>
									<li>Ist einer von euch schon so richtig beeindruckt?</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="more_than_a_hype.jpg"/>
					<aside class="notes">

						<ul>
							<li>Ich bin recht viel unterwegs und sehe recht viele technologien</li>
							<li>Grade wenn ich architekturlastige arbeiten mit Teams mache, fühle ich mich oft öhnlich wie auf dem Bild</li>
							<li>Hypes werden ausprobiert, es entwickeln sich technologien draus</li>
							<li>Ich würd euch gerne in den nächsten Minuten erzählen warum das auf Rust nicht zutrifft, sprich, warum Rust kein Hype ist.</li>
							<li>Dafür müssen wir ein wenig in der Historie rumgraben</li>
							<li>Aber lasst uns erstmal auf der Startseite anfangen</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="rust_lang_org_startpage1.png">
					<aside class="notes">
						<ul>
							<li>Da schon wieder der Begriff system programming</li>
							<li>ist das php auch? wohl eher web programming, mhhmm</li>
							<li>und rust will "blazingly fast" sein</li>
							<li>ok, nichts neues, das sind C und C++ z.b. auch</li>
						</ul>
					</aside>>
				</section>

				<section>
					<img src="rust_lang_org_startpage2.png">
					<aside class="notes">
						<ul>
							<li>prevents segfaults - kennt jemand segfaults?</li>
							<li>
								Das sind die Fehler die z.b.
								<ul>
									<li>PHP Intern sind und kein spass zum Debuggen machen</li>
									<li>hab ich häufiger mal wenn ich gewaltige tests suits laufen lasse</li>
									<li>
										Wäre PHP also in Rust geschrieben, dann könnte es diese art von Fehlern nicht geben?
										<ul>
											<li>Krass</li>
											<li>Absolutes alleinstellungsmerkmal unter "System programming" sprachen.</li>
										</ul>
									</li>
									<li>
										thread safety ist auch so ne sache
										<ul>
											<li>Threading ist hart</li>
											<li>Rust ist die erste sprache, welche thread safety erzwingen kann</li>
										</ul>
									</li>
									<li>
										Wie macht rust das alles?
										<ul>
											<li>Es kompilliert schlicht nicht, wenn es sich nicht sicher ist.</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="mozilla.png">

					<aside class="notes">
						<ul>
							<li>Rust wurde von Mozilla entwickelt</li>
							<li>Mozilla hat das Problem, dass sie eine gewaltige C / C++ Base haben</li>
							<li>
								9 Jahre hat Mozilla daran gewerkelt an Rust zu arbeiten
							</li>
							<li>Stell dir vor, du bist Mozilla.</li>
							<li>Es gibt (für mich) ein paar Sprachgattungen.</li>
						</ul>

					</aside>
				</section>

				<section>
					<img src="img_lang_types/interpreter.png">

					<aside class="notes">
						<ul>
							<li>Erste Gattung: Interpretersprachen</li>
							<li>Warum eigenet sich eine Sprache wie PHP (oder z.b. Python) nicht so gut, um einen Browser zu entwickeln?</li>
							<li>Android</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img_lang_types/jit.png">

					<aside class="notes">
						<ul>
							<li>Warum eignet sich z.b. Java nicht um z.b. einen Browser zu implementieren?</li>
							<li>Langsam</li>
							<li>Kostspielig (Ramverbrauch ....)</li>
							<li>Native schnittstellen sind nicht wirklich nutzbar -> OS ist in anderer Sprache geschrieben.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img_lang_types/native_runtime.png">

					<aside class="notes">
						<ul>
							<li>Eine recht frisch aufstrebene Gattung von Sprache</li>
							<li>Nativer Code welcher eine eigene Runtime mitbringt.</li>
							<li>
								Gründe werden weniger, fällt wem noch was ein?
								<ul>
									<li>GC ist ein problem, stellt euch ein videoplayback vor, was hin und wieder mal stoppt weil der gc läuft (bei Java teilweise minuten (TB Ram))</li>
									<li>Durch den GC kann man nicht wirklich sinnvoll C callen, bzw von C gecalled werden.</li>
									<li>Treiber oder PHP Extensions lassen sich aus diesem grund nicht wirklich sinnvoll mit solchen sprachen schreiben.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img_lang_types/native_without_rust.png">
					<aside class="notes">
						<ul>
							<li>In diesen Sprachen geht das, aber warum macht's kein spass?</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>
						all important stuff
					</h2>
					<h2>
						is written in
					</h2>
					<h1>
						C / C++
					</h1>

					<aside class="notes">
						<ul>
							<li>Warum ist das eigentlich so?</li>
							<li>Mozilla beispielsweise hat das Problem, dass es Firefox maintaint.</li>
							<li>Trotz enormer sorgfalt, gibt es immer wieder segaults und sicherheitsprobleme mit dem speichermanagement.</li>
							<li>threading ist unheimlich hart (dadurch oft nicht optimal eingesetzt u.s.w.)
							<li>Warum aber muss Mozilla C++ oder C für den Firefox verwenden?</li>
						</ul>

						Und wo gleidert sich rust hier ein?
					</aside>
				</section>


				<section>
					<img src="rust_more_control_more_safety.png"/>
					<br/>
					<a href="http://people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/2/1">people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/2/1</a><br/>
					<a href="https://www.youtube.com/watch?v=agzf6ftEsLU">youtube.com/watch?v=agzf6ftEsLU</a>

					<aside class="notes">
						<ul>
							<li>Rust setzt genau hier an und ist in der C / C++ Sprachfamilie</li>
							<li>Ist C und C++ in der Sprachentwicklung allerdings um Jahrzehnte vorraus.</li>
							<li>
								Mozilla hat sehr hart daran entwickelt
								<ul>
									<li>Vermutlich eine der Sprachen mit dem höchsten Researcheinsatz</li>
								</ul>
							</li>
						</ul>

						Hier ein paar Goodies die Rust mitbringt.
				</section>

				<section>
					<h2>
						C++ Fehlerhandling
					</h2>
					<img src="cpp_error_messages.png"/>
				</section>

				<section>
					<h2>
						C++ Fehlerhandling
					</h2>
					<img src="cpp_error_messages2.png"/>
				</section>

				<section>
					<h1>
						Kein "PHPStorm".
					</h1>
				</section>

				<section>
					<h1>
						Kein "Composer".
					</h1>
				</section>

				<section>
					<h1>
						Memory Management.
					</h1>
				</section>
				<section>
					<img src="php_bugtracker_segmentation.png">
				</section>
				<section>
					<img src="php_bugtracker_overflow.png">
				</section>


				<section>
					<img src="rust_more_control_more_safety.png"/>
					<br/>
					<a href="http://people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/2/1">people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/2/1</a><br/>
					<a href="https://www.youtube.com/watch?v=agzf6ftEsLU">youtube.com/watch?v=agzf6ftEsLU</a>

					<aside class="notes">
						- Rust löst alle diese dinge ...
						- wenn man sich vor augen führt, dass alles wichtige, in so einer "matschigen" Sprache geschrieben ist,
						dann kann Rust eine echte Rettung sein.
						- C / C++ mit dem strengsten Compiler der Welt + dem ganzen Facy scheiss aus der Ruby Community
					</aside>

				</section>

				<section>
					<img src="decisions_of_performance.png"><br/>
					<a href="https://www.youtube.com/watch?v=9By9KLs51Dc">youtube.com/watch?v=9By9KLs51Dc</a>
				</section>
<!--
				<section>
					<h2>
						Kein GC, Effizientes Speichermanagement.<br/>
						Rust braucht kein free()
					</h2>
				</section>


				<section>
					<img src="php_gc.png"/>
					<div class="notes">
						Was für Probleme bringt das mit?
					</div>
				</section>

				<section>
					<pre><code data-trim data-noescape>
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main() {

	char *str = (char *) malloc(sizeof(char) * 3);
	str[0] = 'a';
	str[1] = 'b';
	str[2] = '\0';

	printf("%s",str);

	return 0;
}
					</code></pre>
					<aside class="notes">
						gcc -c main.c
					</aside>
				</section>

				<section>
					<pre><code data-trim data-noescape>
/usr/local/Cellar/valgrind/HEAD/bin/valgrind --tool=memcheck ./a.out
==6343== Memcheck, a memory error detector
==6343== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==6343== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info
==6343== Command: ./a.out
==6343==
ab==6343==
==6343== HEAP SUMMARY:
==6343==     in use at exit: 38,722 bytes in 416 blocks
==6343==   total heap usage: 516 allocs, 100 frees, 45,698 bytes allocated
==6343==
==6343== LEAK SUMMARY:
==6343==    definitely lost: 3 bytes in 1 blocks
==6343==    indirectly lost: 0 bytes in 0 blocks
==6343==      possibly lost: 0 bytes in 0 blocks
==6343==    still reachable: 0 bytes in 0 blocks
==6343==         suppressed: 38,719 bytes in 415 blocks
==6343== Rerun with --leak-check=full to see details of leaked memory
==6343==
==6343== For counts of detected and suppressed errors, rerun with: -v
==6343== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
					</code></pre>
					<aside class="notes">
						gcc -c main.c
					</aside>
				</section>
				<section>
					<pre><code data-trim data-noescape>
➜  c1 /usr/local/Cellar/valgrind/HEAD/bin/valgrind --tool=memcheck ./a.out
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main() {

    char *str = (char *) malloc(sizeof(char) * 3);
    str[0] = 'a';
    str[1] = 'b';
    str[2] = '\0';

    printf("%s",str);

    free(str);

    return 0;
}
					</code></pre>
					<aside class="notes">
						mit free
					</aside>
				</section>
				<section>
					<pre><code data-trim data-noescape>
/usr/local/Cellar/valgrind/HEAD/bin/valgrind --tool=memcheck ./a.out
==6458== Memcheck, a memory error detector
==6458== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==6458== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info
==6458== Command: ./a.out
==6458==
--6458-- run: /usr/bin/dsymutil "./a.out"
warning: no debug symbols in executable (-arch x86_64)
ab==6458==
==6458== HEAP SUMMARY:
==6458==     in use at exit: 38,719 bytes in 415 blocks
==6458==   total heap usage: 516 allocs, 101 frees, 45,698 bytes allocated
==6458==
==6458== LEAK SUMMARY:
==6458==    definitely lost: 0 bytes in 0 blocks
==6458==    indirectly lost: 0 bytes in 0 blocks
==6458==      possibly lost: 0 bytes in 0 blocks
==6458==    still reachable: 0 bytes in 0 blocks
==6458==         suppressed: 38,719 bytes in 415 blocks
==6458==
==6458== For counts of detected and suppressed errors, rerun with: -v
==6458== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
					</code></pre>
					<aside class="notes">
						mit free
					</aside>
				</section>
				<section>
					<pre><code data-trim data-noescape>
➜  c1 /usr/local/Cellar/valgrind/HEAD/bin/valgrind --tool=memcheck ./a.out
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main() {

    char *str = (char *) malloc(sizeof(char) * 3);
    str[0] = 'a';
    str[1] = 'b';
    str[2] = '\0';

    printf("%s",str);

    free(str);
    free(str);

    return 0;
}
					</code></pre>
					<aside class="notes">
						mit free
					</aside>
				</section>
				<section>
					<pre><code data-trim data-noescape>
/usr/local/Cellar/valgrind/HEAD/bin/valgrind --tool=memcheck ./a.out
==6568== Memcheck, a memory error detector
==6568== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==6568== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info
==6568== Command: ./a.out
==6568==
--6568-- run: /usr/bin/dsymutil "./a.out"
warning: no debug symbols in executable (-arch x86_64)
==6568== Invalid free() / delete / delete[] / realloc()
==6568==    at 0x10000923F: free (in /usr/local/Cellar/valgrind/HEAD/lib/valgrind/vgpreload_memcheck-amd64-darwin.so)
==6568==    by 0x100000F4C: main (in ./a.out)
==6568==  Address 0x1008008f0 is 0 bytes inside a block of size 3 free'd
==6568==    at 0x10000923F: free (in /usr/local/Cellar/valgrind/HEAD/lib/valgrind/vgpreload_memcheck-amd64-darwin.so)
==6568==    by 0x100000F43: main (in ./a.out)
==6568==  Block was alloc'd at
==6568==    at 0x100008DFB: malloc (in /usr/local/Cellar/valgrind/HEAD/lib/valgrind/vgpreload_memcheck-amd64-darwin.so)
==6568==    by 0x100000F0A: main (in ./a.out)
==6568==
ab==6568==
==6568== HEAP SUMMARY:
==6568==     in use at exit: 38,719 bytes in 415 blocks
==6568==   total heap usage: 516 allocs, 102 frees, 45,698 bytes allocated
==6568==
==6568== LEAK SUMMARY:
==6568==    definitely lost: 0 bytes in 0 blocks
==6568==    indirectly lost: 0 bytes in 0 blocks
==6568==      possibly lost: 0 bytes in 0 blocks
==6568==    still reachable: 0 bytes in 0 blocks
==6568==         suppressed: 38,719 bytes in 415 blocks
==6568==
==6568== For counts of detected and suppressed errors, rerun with: -v
==6568== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
					</code></pre>
					<aside class="notes">
						mit free
					</aside>
				</section>
-->
				<section>
					<img src="ownership_in_c.png"/>
					<br/>
					<a href="http://people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/4/1">people.mozilla.org/~acrichton/rust-talk-2014-12-10/#/4/1</a>
					<aside class="notes">
						<ul>
							<li>Die Folie hab ich geklaut</li>
							<li>Hier ein wenig C code</li>
							<li>Das problem ist, dass slot verwendet wird, nachdem es freigegeben wird.</li>
							<li>Die funktion helper gibt slot frei</li>
							<li>angenommen eine funktion gibt einen string zurück, welche funktion gibt diesen wieder frei?</li>
							<li>Urproblem aller segfaults ...</li>
							<li>Ich hatte zu dem thema einige slides, die finden sich auskommentiert in meinem Repo inkl einer C Beispielanwendung die ich aus zeitgründen heut nicht mit euch durchgehe</li>
						</ul>
					</aside>
				</section>

				<section>

					<h2>Wie löst Rust das "Problem"?</h2>

					<div class="editor">
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "PHPUG".to_string();

	greet(name);
	greet(name);
}
					</div>

					<div class="php_example" data-php-example="https://3v4l.org/OB8EK">

function greet(string $name) {
    echo "Hello ". $name . "\n";
}

$name = "PHPUG";
greet($name);
greet($name);
					</div>

					<aside class="notes">
						<ul>
							<li>Fehlermeldung ansehen</li>
							<li>PHP Code ansehen</li>
							<li>einen Aufruf wegnehmen</li>
							<li>String zu Integer tauschen und zeigen, dass es geht.</li>
							<li>
								in C programmen sieht man oft, dass irgendwas aus "sicherheitsgründen" sprich weil niemend mehr durchblickt kopiert wird,
								durch das "sichere" moven kann man hier echt performance rausholen.
							</li>
							<li>
								alles zero cost -> keine runtime performance
							</li>
						</ul>
					</aside>
				</section>
				<section>

					<h2>Borrowing</h2>

					<div class="editor">
pub fn greet(name : &String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "PHPUG".to_string();

	greet(&name);
	greet(&name);
}
					</div>
					<aside class="notes">
						<ul>
							<li>Die alternative sind referenzen</li>
							<li>Referenzen können mutable oder immuntable sein</li>
							<li>Wichtig ist, sie können das objekt nicht löschen</li>
							<li>Zero cost ...</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>"ownership" löst das free() Problem.</h3>
				</section>

				<section>
					<div class="editor">
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
						</div>

					<aside class="notes">
						<ul>
							<li>etwas komplexeres Beispiel</li>
							<li>ein Owner kann ein Struct oder eine Funktion sein</li>
							<li>in diesem Fall (syntax für lambda) wird eine Lambda erstelt</li>
							<li>die lambda wird owner von data</li>
							<li>Data kann nur einen Owner haben -> womit dies nicht kompilliert</li>
						</ul>
					</aside>

				</section>

				<section>
					<div class="editor">
use std::thread;
use std::time::Duration;

fn main() {
    let data = vec![1, 2, 3];

    for i in 0..3 {

        let mut x = data[i].clone();

        thread::spawn(move || {
            x += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
						</div>
					<aside class="notes">
						<ul>
							<li>ein Quick Fix wäre einfach die daten zu kopieren</li>
							<li>dies ist nun threadsafe weil x in die lambda gemoved werden kann</li>
							<li>doof nur, dass man diese ja dann nicht mehr ausgeben kann</li>
						</ul>
					</aside>
				</section>

				<section>
					<div class="editor">
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
					</div>
					<aside class="notes">
						<ul>
							<li>Um das wirklicj zu fixen brauchen wir sowas wie einen Mutex</li>
							<li>Dieser hebelt mit sogenannten unsafe code den borrow checker aus</li>
							<li>Der mutex selbst ist also in Rust geschrieben</li>
							<li>Wir beschäftigen uns heute nicht damit wie dieser intern funktioniert</li>
							<li>wichtig ist, es ist total safe diesen zu nutzen.</li>
							<li>Fehler führen schlicht dazu, dass dies nicht kompilliert.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Rusts Ownership bedeutet sichere parallele Programmierung.</h3>
					<h5>Selbst wenn PHP-Entwickler involviert sind.</h5>
					<aside class="notes">
						absolutes alleinstellungsmerkmal.
						es gibt nette libs, die regeln sind auch bei denen "erzwungen"
					</aside>
				</section>

				<section>
					<h1>Effizientes Memory Management.</h1>
					<h5>Heap vs. Stack</h5>
					<aside class="notes">
						<ul>
							<li>
								Warum wird PHP standardmäßig nicht thread safe kompilliert
								<ul>
									<li>refcounting ist z.b. kostspieliger</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>
<!--
				<section>
					<div class="editor">
pub fn main() {
	let a = "Foo";
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/OdOXv">
$a = "Foo";
					</div>

				</section>
-->

				<section>
					<div class="editor">
pub fn main() {
	// Embeddet den UTF-8 String "Foo" in der Binary
	// erstellt eine Referenz auf den "String-Slice" und erlaubt den Zugriff via a
	let a = "Foo";
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/MMpFb">
// Frag den Ram nach Platz für ne Zval
//
// typedef union _zvalue_value {
//    long lval;                 /* long value */
//    double dval;               /* double value */
//    struct {
//        char *val;
//        int len;               /* this will always be set for strings */
//    } str;                     /* string (always has length) */
//    HashTable *ht;             /* an array */
//    zend_object_value obj;     /* stores an object store handle, and handlers */
// } zvalue_value;
//
// registriere die variable im GC

$a = "Foo";
// und prüf hin und wieder und am ende, ob die variable noch gebraucht wird

					</div>
					<aside class="notes">
						let a = "Foo".to_string();
						println!("{}", a);

						den assembler code (release) von der menge zeigen.
					</aside>
				</section>

				<section>
					<div class="editor">
# sudo dtrace -n 'pid$target::malloc:entry' -c "./target/release/malloc"

pub fn foo() -> &'static str {
    return "fooooo";
}

fn main() {

    println!("------------");

    loop {
        println!("{}", foo());
    }
}
					</div>
					<div class="php_example">
# sudo dtrace -n 'pid$target::malloc:entry' -c "php malloc.php"

function foo() {
    return "fooooo";
}

echo "------------------------\n";
sleep(2);

while(true) {
    $a = foo();
    sleep(0.5);
}
					</div>
				</section>


				<section>
					<h2>Installation</h2>
					Rustup / (apt / compile your own / phpbrew)

					<aside class="notes">
						<ul>
							<li>Bei Rust ist es so, dass die stable im packagemanager ist.</li>
							<li>Alle nutzen aber eigentlich das rustup projekt welches sowas ist wie phpbrew</li>
							<li>bei php kompilliere ich mir idr die versionen selbst.</li>
						</ul>
					</aside>
				</section>

				<section>
					<pre>
$ phpbrew install 5.4.0 +default

$ phpbrew use 5.4.22
					</pre>
					<aside class="notes">
						<ul>
							<li>phpbrew verwaltet also mehrere php versionen gleichzeitig</li>
							<li>man kann dann einfach sagen welche man haben möchte und diese wechseln</li>
							<li>so kann man auch einfach extensions mit drauf installieren</li>
						</ul>
					</aside>
				</section>

				<section>
					<pre>
$ curl https://sh.rustup.rs -sSf | sh

$ rustup default nightly
					</pre>
					<aside class="notes">

						<ul>
							<li>Rustup funktioniert wie phpbrew</li>
							<li>einfaches update command und man ist auf der neusten version.</li>
							<li>den bedarf für module gibts nicht, weil rust ja in rust geschrieben ist</li>
							<li>
								Rustup kann auch sehr einfach Cross kompilieren
								<ul>
									<li>Das Rust Team arbeietet hard daran, dass es kein Problem ist</li>
									<li>Von Windows auf Linux zu kompillieren</li>
									<li>von Irgendwas auf ARM</li>
									<li>Momentan werden 32 Targets unterstützt, sowas wie Android, Freebsd, Powerpc...</li>
								</ul>
							</li>
						</ul>

						➜  rust_for_php_devs git:(master) ✗ rustup toolchain list
						stable-x86_64-apple-darwin
						nightly-2016-03-14-x86_64-apple-darwin
						nightly-2016-03-27-x86_64-apple-darwin
						nightly-2016-05-10-x86_64-apple-darwin
						nightly-2016-05-20-x86_64-apple-darwin
						nightly-2016-05-27-x86_64-apple-darwin

						➜  rustup target list
					</aside>
				</section>

				<section>
					<h2>Package Management</h2>
					cargo / composer
				</section>

				<section>
					<h2>composer</h2>
					<p>
						composer.json / composer.lock
					</p>
					<img src="composer_json.png">
				</section>

				<section>
					<h2>cargo</h2>
					<p>
						Cargo.toml / Cargo.lock
					</p>
					<img src="cargo.png">
				</section>

				<section>
					<h2>cargo</h2>
					<pre>
$ cargo new --bin hellophpug

$ cargo run
					</pre>
				</section>

				<section>
					<h2>IDE?</h2>
					<img src="ide.png"/>
				</section>

				<section>
					<h2>PHP "Basics"</h2>
					include, autoloader, namespaces, tests
				</section>

				<section>
					<h3>Autoloader + Namespaces</h3>
					<div class="editor" data-php-example="https://3v4l.org/pcmBV">
mod foo;
					</div>

					<div class="php_example" data-php-example="https://3v4l.org/pcmBV">


if (
	file_exists($mod.'.rs') &&
	file_exists($mod.'/mod.rs')
) {
    throw new \Exception(
        '[file].rs or [file]/mod.rs?'
    );
} else if (file_exists($mod.'.rs')) {
    include $mod.'.rs';
} else if (file_exists($mod.'.rs')) {
    include $mod.'/mod.rs';
}
					</div>

					<aside class="notes">
						<ul>
							<li>mod ist quasi das include von rust</li>
							<li>natürlich komplett compile time</li>
							<li>es funktioniert ein wenig so wie der code</li>
							<li>es prüft ob foo.rs da ist</li>
							<li>es prüft ob foo/mod.rs da ist</li>
							<li>das liebe ich so an rust: wenn beides da ist gibts nen fehler</li>
							<li>rust versucht immer maximal strikt zu bleiben, implizite typenumwandlungen gibt es in rust z.b. auch nicht</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Autoloader + Namespaces</h3>
					<div class="editor">
use foo::Bar;
use foo::{Bar, Bazz};
pub use foo::Bar;
					</div>

					<aside class="notes">
						<ul>
							<li>use ist wie in php</li>
							<li>pub use wird genutzt, um module anderen "crates" zur Verfügung zu stellen, sprich anderen Bibliotheken.</li>
							<li>In php ist es so, dass alles immer zugriff auf alles hat.</li>
							<li>Deptrac ist ein Tool was genau dieses fehlende Sprachfeature kompensiert.</li>
							<li>in Java gibts auch public classes.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Tests</h3>
					<div class="editor">
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
					</div>

					<aside class="notes">
						<ul>
							<li>cargo doc generiert api docs</li>
							<li>beste api docs die ich kenne (mit suchfunktion)</li>
							<li>api docs fürs ganze projekt</li>
							<li>code beispiele werden als tests ausgeführt.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h5>Lets "write" a small webserver.</h5>
				</section>

				<section>
					<pre><code data-trim data-noescape>
$ cargo new --bin webfoo
					</code></pre>
					<pre><code data-trim data-noescape>
[dependencies]
nickel = "*"
					</code></pre>
					<pre><code data-trim data-noescape>
#[macro_use] extern crate nickel;

use nickel::{Nickel, HttpRouter};

fn main() {
	let mut server = Nickel::new();

	server.get("/", middleware!(
		let a = "Hello World";
		a
	));

	server.get("/bar", middleware!("Bar"));
	server.listen("127.0.0.1:6767");
}
					</code></pre>
					<pre><code data-trim data-noescape>
$ cargo run
					</code></pre>

					<aside class="notes">
						<ul>
							<li>das wars, probiert es aus.</li>
							<li>hat eher so ein wenig node.js charm</li>
							<li>garantiert thread safe, selbst wenn ich den code daginter nicht verstehe - rust garantierts mir</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Ein wenig mehr OOP</h3>
				</section>

				<section>
					<div class="editor">
struct Person {
    age : i32
}

impl Person {

    pub fn new(age : i32) -> Person {
        Person {
            age: age
        }
    }

    pub fn get_age(&self) -> i32 {
        self.age
    }
}

fn main() {

    let tim = Person::new(25);

    println!("Tim is {} years old", tim.get_age());
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/JOsMi">

class Person {

    private $age;

    function __construct($age) {
        $this->age = $age;
    }

    function getAge() {
        return $this->age;
    }
}

echo sprintf(
	"Tim is %d years old",
	(new Person(25))->getAge()
);
					</div>
					<aside class="notes">
						<ul>
							<li>mir ist immer oop ganz wichtig, daher hier noch mal ein oop example</li>
							<li>hier sehen wir auch das erste mal einen gett</li>
							<li>achtet mal genau auf das &self</li>
							<li>das ist wie bei python</li>
							<li>funktionen mit dem &self, leihen sich eine referenz darauf, klassische methoden</li>
							<li>methoden ohne self sind static</li>
						</ul>
					</aside>
				</section>

				<section>
					<div class="editor">
fn main() {

    let a;

    if true {
        a = "Ja";
    } else {
        a = "Nein";
    }

    println!("{}", a);
}

					</div>
					<aside class="notes">
						etliche variationen (unitialisiert / if return value))
						Rust -> safe
					</aside>
				</section>

				<section>
					<div class="editor">
fn main() {

    let names = vec![
        "Tim",
        "Chris",
        "Freerich"
    ];

    println!("{}", names.join(", "));
}


					</div>
					<aside class="notes">
						einfache arrays ...
					</aside>
				</section>

				<section>
					<div class="editor">
fn main() {

    let mut names = vec![];
    names.push("Tim");
    names.push("Chris");
    names.push("Freerich");

    println!("{}", names.join(", "));
}


					</div>
					<aside class="notes">
						arrays sind "veränderbar" nicht so wie bei c
					</aside>
				</section>

				<section>
					<div class="editor">
fn main() {

    let mut names = Vec::new();
    names.push("Tim");
    names.push("Chris");
    names.push("Freerich");

    println!("{}", names.join(", "));
}

					</div>
					<div class="notes">
						Compiler Warnung bei:

						fn main() {

							let mut names = Vec::new();

							println!("{}", names.join(", "));
						}

					</div>
				</section>

				<section>
					<img src="never_use_null_qafoo.png"><br/>
					<a href="https://qafoo.com/blog/083_never_use_null.html">qafoo.com/blog/083_never_use_null</a>
				</section>

				<section>

						<div class="editor">
#[derive(Debug)]
struct BlogPost;

fn get_blog_post_by_uuid(uuid : &str) -> Option&lt;BlogPost&gt; {
	if uuid == "1234-abcdef" {
		return Some(BlogPost {});
	}

	None
}

fn main() {


}
					</div>
					<aside class="notes">
						<ul>
							<li>Rust kennt kein "Null"</li>
							<li>Rust kennt nur "options"</li>
							<li>kann das sein, oder nichts</li>
							<li>Prüft man nicht, sondern ruft einfach "unwrap" auf einer option auf, so panict im zweifel das programm und ist beendet</li>
							<li>das programm ist somit nie in einem "komischen" zustand</li>
							<li>benutzt man unwrap nicht, kann das programm in keinen dieser zustände kommen</li>
							<li>wer würde schon ein herzschrittmacher in php entwickeln?</li>
						</ul>
					</aside>
				</section>


				<section>

					<div class="editor" data-php-example="https://3v4l.org/YXD9n">
fn main() {
	let numbers = vec![1, 2, 3, 4, 5, 6, 10, 100];

	let result: Vec&lt;_&gt; = numbers.iter()
	.filter(|&x| *x &gt; 4)
	.filter(|&x| *x &lt; 100)
	.map(|x| x * 2)
	.chain(10..11)
	.collect();

	println!("{:#?}", result);
}

					</div>
					<div class="php_example" data-php-example="https://3v4l.org/JOsMi">
$numbers = [1, 2, 3, 4, 5, 6, 10, 100];

$result =
	array_values(array_map(
		function($a) { return $a * 2; },
		array_filter(
			array_filter($numbers, function($a) { return $a > 4; }),
			function($a) { return $a < 100; }
		)
	));

$result[] = 10;
$result[] = 11;

var_dump($numbers);

					</div>

					<aside class="notes">

					</aside>
				</section>

				<section>
					<h3>Generics</h3>
					<div class="editor">
enum May&lt;T> {
    Value(T),
    Empty
}

impl&lt;T&gt; May&lt;T&gt; {
    pub fn unwrap(&self) -> &T {
        match self {
            &May::Value(ref v) => v,
            &May::Empty => panic!("yolo")
        }
    }
}

fn main() {
    println!("{}", May::Value::&lt;i32&gt;(10).unwrap());
    println!("{}", (May::Empty::&lt;i32&gt;).unwrap());
}
					</div>
					<div class="php_example" data-php-example="https://3v4l.org/Sp3qc">

class Option&lt;T&gt; {

    private T $value;

    public function __construct(T $value) {
        $this->value = $value;
    }

    public function unwrap() {
        if ($this->value === null) { die('yolo'); }
        return $this->value;
    }
}

echo (new Option&lt;String&gt;("hello"))->unwrap();
echo (new Option&lt;String&gt;(null))->unwrap();

					</div>
				</section>

				<section>
					<h3>Community</h3>
				</section>

				<section>
					<img src="community/rust_community_team.png"/>
				</section>
				<section>
					<img src="community/packagist_stats.png"/>
				</section>
				<section>
					<img src="community/crates.png"/>
				</section>
				<section>
					<img src="community/crates_index.png"/>
				</section>
				<section>
					<img src="community/rust_book.png"/>
				</section>
				<section>
					<img src="community/rust_playbot.png"/>
				</section>
				<section>
					<img src="community/rust_most_loved.png"/>
				</section>
				<section>
					<img src="community/rust_n64.png"/>
				</section>
				<section>
					<img src="community/write_os_in_rust.png"/>
				</section>
				<section>
					<img src="community/rust_rfcs.png"/>
				</section>
				<section>
					<img src="community/rust_by_example.png"/>
				</section>

				<section>
					<h3>Projects</h3>
				</section>
				<section>
					<img src="projects/bindings.png"/>
				</section>
				<section>
					<img src="projects/diesel_faster_than_c.png"/>
				</section>
				<section>
					<img src="projects/redox.png"/>
				</section>
				<section>
					<img src="projects/rust_helix.png"/>
				</section>
				<section>
					<img src="projects/rust_php_extension.png"/>
				</section>
				<section>
					<img src="projects/rust_vulkan.png"/>
				</section>
				<section>
					<img src="projects/nom.png"/>
				</section>
				<section>
					<img src="projects/tagua-vm.png"/>
				</section>

				<section>
					<iframe width="560" height="315" src="https://www.youtube.com/embed/u0hYIRQRiws" frameborder="0" allowfullscreen></iframe>
				</section>

				<section>
					<img src="why_rust/rust_dropbox.png">
				</section>

				<section>
					<img src="why_rust/why_rust.png">
				</section>

				<section>
					<img src="why_rust/rust_forks.png">
				</section>

				<section>
					<img src="rust_survey/time_using_rust.png">
				</section>
				<section>
					<img src="rust_survey/do_you_use_rust_at_work.png">
				</section>
				<section>
					<img src="rust_survey/do_you_plan_to_use_rust_at_work.png">
				</section>
				<section>
					<img src="rust_survey/what_areas_do_you_work_in.png">
				</section>
				<section>
					<img src="community/rust_usergroup.png">
				</section>
				<section>
					<img src="community/rust_usergroup2.png">
				</section>
				<section>
					<img src="community/rustfest_eu.png">
				</section>


				<section>
					<h3>thx :)</h3>
					<h4>Fragen?</h4>
				</section>

				<section>
					<img src="rust_is_hard.png"/>
					<small>
						<a href="https://medium.com/@deckarep/paradigms-of-rust-for-the-go-developer-210f67cd6a29#.7chiq0tzq">https://medium.com/@deckarep/paradigms-of-rust-for-the-go-developer</a>
					</small>
				</section>

				<section>
					<h3>Lifetimes</h3>
					<div class="editor">
struct Person {
	name : String
}

fn main() {

	let name = "tim".to_string();

	let tim = Person { name: name };
	//let freerich = Person { name: name };

}
					</div>
				</section>

				<section>
					<h3>Lifetimes</h3>
					<div class="editor">
struct Person<'a> {
	name : &'a str
}

fn main() {
	let name = "tim";

	let tim = Person { name: &name };
	// let freerich = Person { name: &name };
}
					</div>
				</section>

				<section>
					<h3>map/reduce</h3>
					<img src="MapReduce2.svg.png"/>
				</section>

				<section>
					<h3>Mapper</h3>
					<div class="editor">
extern crate regex;
use std::io;
use std::io::prelude::*;
use regex::Regex;

fn main() {

    let stdin = io::stdin();
    let regex = Regex::new(r"(\d+)$").expect("failed to compile regex");

    for line in stdin.lock().lines() {

        let line : String = line.expect("failed to read line");
        let captures = regex
                        .captures(&line)
                        .expect("failed to capture index")
                        .at(0)
                        .expect("failed to read int");

        println!("{}\t1", captures);
    }
}
					</div>
					<div class="php_example">
while (($line = fgets(STDIN)) !== false) {
    $matches = [];
    preg_match('/\d+$/', $line, $matches);
    if (!isset($matches[0])) {
        continue;
    }
    $url_number = $matches[0];
    echo $url_number."\t".'1'."\n";
}
					</div>
				</section>

				<section>
					<h3>Reducer</h3>
					<div class="editor">
use std::io;
use std::io::prelude::*;

fn main() {

    let stdin = io::stdin();
    let mut last_number : Option&lt;i32&gt; = None;
    let mut last_count = 0;

    for line in stdin.lock().lines() {

        let line : String = line.expect("failed to read line");
        let mut split = line.split("\t");

        let key = split
                    .next()
                    .expect("key must be given")
                    .parse::&lt;i32&gt;()
                    .expect("key must be an int");

        let value = split
                    .next()
                    .expect("value must be given")
                    .parse::&lt;i32&gt;()
                    .expect("value must be an int");

        if last_number.is_none() {
            last_number = Some(key);
        }

        if last_number.unwrap() == key {
            last_count += value;
            continue;
        }

        println!(
            "{}\t{}",
            last_number.expect("number cant be null"),
            last_count
        );

        last_count = 1;
        last_number = Some(key);
    }

    if last_count != 0 && last_number.is_some() {
        println!(
            "{}\t{}",
            last_number.expect("number cant be null"),
            last_count
        );
    }
}
					</div>
					<div class="php_example">
$lastNumber = null;
$lastCount = 0;
while (($line = fgets(STDIN)) !== false) {
    list($number, $count) = explode("\t", $line);
    if ($lastNumber === null) {
        $lastNumber = $number;
    }
    if ($lastNumber === $number) {
        $lastCount++;
        continue;
    }
    echo $lastNumber."\t".$lastCount."\n";
    $lastCount = 1;
    $lastNumber = $number;
}
if ($lastCount && $lastNumber) {
    echo $lastNumber."\t".$lastCount."\n";
}
					</div>
				</section>




			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					//{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
